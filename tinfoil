#!/usr/bin/env zsh
#
# Tinfoil
#
# A tool to manage multiple profiles for web browsers
#
# {{{ License
#
# Copyright (C) 2017 Dyne.org Foundation
#
# Tinfoil is designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source code is free software; you can redistribute it and/or
# modify it under the terms of the GNU Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This source code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Please refer
# to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to: Free Software Foundation, Inc.,
# 675 Mass Ave, Cambridge, MA 02139, USA.

# }}} - License

# {{{ Initialisation

# resources in order of priority
# this is where tinfoil looks for template/ and firejail/ dirs
homedir=$HOME/.tinfoil
# this can be changed, for instance to move templates in a tomb
profiledir=${TINFOIL_HOME:-$homedir/profiles}

confdir=/etc/tinfoil
# this is changed to $PREFIX/share/tinfoil by make install
basedir=.

source $basedir/zuper/zuper

# globals
vars+=(browser family profile)
vars+=(profiledir homedir confdir basedir)
vars+=(templatedir create_profile profilepath)
vars+=(found here)
vars+=(firejail_profile)
maps+=(browsertype vendor profilename)
arrs+=(browser_opts prefs)

source $basedir/zuper/zuper.init

# the vendor() map is used to get $familypath
# familypath="$HOME/.${vendor[$browser]}"
vendor=(firefox     "mozilla/firefox"
		firefox-esr "mozilla/firefox"
		iceweasel   "mozilla/firefox"
		icecat      "mozilla/icecat"
		palemoon    "moonchild productions/pale moon"
	    chromium    ".config/chromium")

here=$(pwd)

function get_browsertype() {
	fn get_browsertype $*
	case $1 in
		chrom*)    browsertype=chrome  ;;
		firefox*)  browsertype=mozilla ;;
		icecat)    browsertype=mozilla ;;
		iceweasel) browsertype=mozilla ;;
		palemoon)  browsertype=mozilla ;;
		*) error "$1 : browser not known to tinfoil"
		   act "use the --type flag to manually select 'mozilla' or 'chrome'"
		   browsertype=""
		   ;;
	esac
}
# }}}

# {{{ Launchers

function setup-profile() {
	fn setup-profile
	req=(profile browser)
	ckreq || return $?

	if [[ $profile =~ anon ]]; then
		notice "Anonymous profile"
		ztmpd
		profilepath="$ztmpdir"/"$browser"
	    template_find || act "no template found"
		if [[ -d "$templatedir" ]]; then
			act "template: $templatedir"
			cp -ra "$templatedir" "$profilepath"
		else
			mkdir -p "$profilepath"
		fi
		[[ "$browsertype" = "chrome" ]] && browser_opts+=(--incognito)
	else

		profilepath="${profiledir}/${browser}.${profile}"
		if [[ -d "$profilepath" ]]; then
			notice "Profile found: $profilepath"
		else
			notice "New profile: $profilepath"
			mkdir -p $profilepath || {
				error "error creating profile directory"
				return 1
			}
			template_find || act "no template found"
			[[ -d "$templatedir" ]] && {
				act "template: $templatedir"
				cp -ra "$templatedir"/* "$profilepath"
			}
		fi
	fi
	return 0
}

function launch-chrome() {
	fn launch-chrome $*
	req=(browser profile)
	freq=($profilepath)
	ckreq || return $?

	func "browser: $browser"
	func "profile: $profile"

	setup-profile

	option.is_set -e && {
		cmd=$(option.value -e)
		act "executable: $cmd"
		$cmd --user-data-dir="$profilepath" ${browser_opts}
		return $?
	}

	$browser --user-data-dir="$profilepath" ${browser_opts}
	return $?
}

function launch-mozilla() {
	fn launch-mozilla
	req=(browser profile)
	ckreq || return $?

	func "browser: $browser"
	func "profile: $profile"

	setup-profile

	familypath="$HOME/.${vendor[$browser]}"

	func "temporary ini: ${familypath}/profiles.ini"
	mkdir -p    "$familypath"
	cat <<EOF > "$familypath"/profiles.ini
[General]
StartWithLastProfile=0
[Profile0]
Name=${profile}
IsRelative=0
Path=${profilepath}
EOF
	[[ $DEBUG = 1 ]] &&
		cat "$familypath"/profiles.ini


	# Inject preferences. We are lucky in browsers of the mozilla
	# family the appended settings override preceeding ones and the
	# unknown ones are ignored
	rm -f "$profilepath"/user.js
	for i in ${prefs}; do
		[[ "$i" = "" ]] || {
			act "config: $i"
			cat "$i" >> "$profilepath"/user.js
		}
	done
	# TODO: interesting to add preference locking functionality
    # see: http://kb.mozillazine.org/Locking_preferences

	browser_is_running "${browser}" || browser_opts+=(-no-remote)

    (sleep 5; rm "$familypath"/profiles.ini) &

	option.is_set -e && {
		cmd=$(option.value -e)
		act "executable: $cmd"
		$cmd ${browser_opts}
		return $?
	}

	$browser ${browser_opts}
	return $?

}

# }}}

# {{{ Misc functions

function help_usage() {
	fn help_usage
	act "Usage: tinfoil browser profile_name"
}

# TODO: check if running from the locks in profile dirs
function browser_is_running() {
	fn browser_is_running
	local arg="$1"
	req=(arg)
	ckreq || return $?

	local res
	func "pgrep: $arg"
	pgrep "$arg" > /dev/null
	res=$?
	[[ $res = 0 ]] && act "$arg is already running"
	return $res
}

# }}}

# {{{ Pathfinders

# a function that recursively searches through symlinks and scripts to
# find the ultimate ELF binary executable they point to. Assumes that
# a shell script contains the binary to call as first argument to the
# first call to ^exec
function executable_find() {
	fn executable_find $*
	local exe="$1"
	req=(exe)
	ckreq || return $?

	local step="$exe"
	local abs=0
	local found=0
	local exepath
	local exetype
	while [[ $found = 0 ]]; do
		func "$step"
		# find full path to current
		[[ "$step[1]" = "/" ]] && abs=1
		[[ "$step[1]" = "." ]] && abs=1
		if [[ $abs = 0 ]]; then
			exepath=$(command -v $step)
			[[ "$exepath" = "" ]] && {
				error "no executable found in path: $step"
				return 1
			}
			func "abs: $exepath"
			abs=1
		else
			exepath=$step
		fi

		exetype="$(file $exepath)"

		# check if a symlink
		[[ $exetype =~ symbolic ]] && {
			step="$(readlink -f $exepath)"
			func "$exepath -> $step"
			continue
		}

		# check if a script, if yes take first exec
		[[ $exetype =~ shell ]] && {
			func "shell script detected"
			for i in ${(f)"$(cat $exepath)"}; do
				func "$i"
				# bail out if nothing found in script
				found=-1
				[[ $i =~ ^exec ]] && {
					step="${i[(w)2]}"
					func "exec: $step"
					found=0
					abs=0
					break
				}
			done
		}

		[[ $exetype =~ ELF ]] && {
			func "binary found: $exepath ($exetype)"
			print $exepath
			return 0
		}
	done
	return $found
}

## looks for a file in all tinfoil directories giving precedence to
## user customisations in $homedir
function cascade_find() {
	fn cascade_find $*
	local file="$1"
	req=(file)
	ckreq || return $?
	found=""
	[[ -r "${here}/${file}" ]] && {
		found="${here}/${file}"
		return 0
	}
	[[ -r "${homedir}/${file}" ]] && {
		found="${homedir}/${file}"
		return 0
	}
	[[ -r "${confdir}/${file}" ]] && {
		found="${confdir}/${file}"
		return 0
	}
	[[ -r "${basedir}/${file}" ]] && {
		found="${basedir}/${file}"
		return 0
	}
}

function template_find() {
	fn template_find
	req=(browser profile)
	ckreq || return $?

	cascade_find "templates/${browser}.${profile}" && {
	   templatedir="$found"
	   return 0
	}

	cascade_find "templates/${browser}" && {
		templatedir="$found"
		return 0
	}


	cascade_find "templates/${browsertype}" && {
		templatedir="$found"
		return 0
	}

	return 1
}

function prefs_find() {
	fn prefs_find
	req=(browsertype)
	ckreq || return $?

	prefs=()
	case $browsertype in
		mozilla)
			cascade_find "templates/${browsertype}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${browser}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${profile}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${browsertype}.${profile}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${browser}.${profile}-prefs.js" && {
				prefs+="$found"
			}

			;;
		chrome)
			# TODO: chromium default preferences
			;;
	esac

	return 0
}

function firejail_find() {
	fn firejail_find
	req=(browser browsertype)
	ckreq || return $?

	firejail_profiles=""

	cascade_find "templates/${browser}.${profile}.firejail" && {
		firejail_profiles+="
include $found"
	}
	cascade_find "templates/${browser}.firejail" && {
		firejail_profiles+="
include $found"
	}
	cascade_find "templates/${browsertype}.firejail" && {
		firejail_profiles+="
include $found"
	}
	return 1
}

# }}}

notice "Tinfoil v0.3"

# {{{ Commands parsed
option_main=(h -help=h v -version=v -tmp: t: -type=t e: -exec=e)
option_subcommands[conf]=""
option.parse $* || return 1
func "subcommand: $subcommand"
option.is_set '-h' && help_usage && return 0

# }}}

# {{{ Main()


# create a new profile
case $subcommand in
	__empty)
		help_usage
		return 0
		;;

	conf)
		# print out the configuration for other wrappers
		browser="${option_params[1]}"
		profile="${option_params[2]}"
		[[ "$profile" = "" ]] && {
			error "usage: $0 conf browser profile"
			return 1
		}
		get_browsertype $browser
		cat <<EOF
browser="$browser"
profile="$profile"
family="$browsertype"
profilepath="~/.tinfoil/profiles/$browser.$profile"
familypath="~/.${vendor[$browser]}"
cachepath="~/.cache/${vendor[$browser]}"
EOF
		cmd=$(executable_find $browser)
		if [[ "$cmd" = "" ]]; then
			warning "executable not found for: $browser"
		else
			cat <<EOF
browser_executable="$cmd"
EOF
		fi
		firejail_find
		[[ "$firejail_profiles" = "" ]] || {
			# list the loaded profiles
			for i in ${(f)firejail_profiles}; do
				[[ $i =~ ^include ]] &&
cat <<EOF
firejail_templates+=(${i[(w)2]})
EOF
			done
		}
		[[ "$prefs" = "" ]] || {
			# list the loaded templates
			for i in ${(f)prefs}; do
				[[ "$i" = "" ]] ||
					cat <<EOF
userjs_templates+=(${i})
EOF
			done
		}

		return 0
		;;

	# default command start with: tinfoil [browser] [profile]
	__unknown:*)
		browser="${subcommand[(ws@:@)2]}"
		profile="${option_params[1]}"

		act "launching browser $browser with profile $profile"
		if option.is_set -t; then
			browsertype=$(option.value -t)
			act "browser type manually selected: $browsertype"
		else
			get_browsertype $browser
		fi

		prefs_find || act "no preference found"
		

		launch-$browsertype
		return $?

		;;

esac



# # support symlinks to script with tinfoil-profilename
# if [[ $0 =~ tinfoil- ]]; then
# 	profile=$(basename $0)
# 	profile=${profile[(ws:-:)2]}
# fi

# browser_opts=($*)



# browser_is_running $browser


## TODO: tor profile to detect tor on local or remote


# }}}
