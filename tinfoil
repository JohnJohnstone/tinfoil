#!/usr/bin/env zsh
#
# Tinfoil
#
# A tool to manage multiple profiles for web browsers
#
# {{{ License
#
# Copyright (C) 2017 Dyne.org Foundation
#
# Tinfoil is designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source code is free software; you can redistribute it and/or
# modify it under the terms of the GNU Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This source code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Please refer
# to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to: Free Software Foundation, Inc.,
# 675 Mass Ave, Cambridge, MA 02139, USA.

# }}} - License

# {{{ Initialisation

# resources in order of priority
# this is where tinfoil looks for template/ and firejail/ dirs
homedir=$HOME/.tinfoil
# this can be changed, for instance to move templates in a tomb
profiledir=${TINFOIL_HOME:-$homedir/profiles}

confdir=/etc/tinfoil
# this is changed to $PREFIX/share/tinfoil by make install
basedir=.

source $basedir/zuper/zuper

# globals
vars+=(profiledir homedir confdir basedir)
vars+=(templatedir create_profile profilepath)
vars+=(found here)
vars+=(firejail_profile)
maps+=(browser browsertype vendor profilename)
arrs+=(browser_opts prefs)

source $basedir/zuper/zuper.init

vendor=(firefox     "mozilla/firefox"
		firefox-esr "mozilla/firefox"
		icecat      "mozilla/icecat"
		palemoon    "moonchild productions/pale moon")

here=$(pwd)

function get_browsertype() {
	fn get_browsertype $*
	case $1 in
		chrom*)   browsertype=chrome  ;;
		firefox*) browsertype=mozilla ;;
		icecat)   browsertype=mozilla ;;
		palemoon) browsertype=mozilla ;;
		*) error "$1 : browser not known to tinfoil"
		   act "use the --type flag to manually select 'mozilla' or 'chrome'"
		   browsertype=""
		   ;;
	esac
}
# }}}

# {{{ Launchers

function launch-chrome() {
	fn launch-chrome $*
    profilepath="${profiledir}/${browser}.${profile}"
	req=(browser profile)
	freq=($profilepath)
	ckreq || return $?

	act "launching     : $browser"
	act "profile path  : $profilepath"

	$app --user-data-dir="$profilepath" ${=browser_opts} $*
}

function launch-mozilla() {
	fn launch-mozilla $*
	func "browser: $browser"
	func "profile: $profile"
    profilepath="${profiledir}/${browser}.${profile}"
	local vendordir="$HOME/.${vendor[$browser]}"
	req=(browser profile vendordir)

	if [[ $profile =~ anon ]]; then
		notice "Anonymous profile"
		# special case, anonymous browsing
		ztmpd
		profilepath="$ztmpdir"/"$browser"
		if [[ -d "$templatedir" ]]; then
			act "using template: $templatedir"
			cp -ra "$templatedir" "$profilepath"
		else
			mkdir -p "$profilepath"
		fi
	else
		if [[ -d "$profilepath" ]]; then
			notice "profile found: $profilepath"
		else
			notice "creating profile: $profilepath"
			mkdir -p $profilepath || {
				error "error creating profile directory"
				return 1
			}
			[[ -d "$templatedir" ]] && {
				act "using template: $templatedir"
				cp -ra "$templatedir"/* "$profilepath"
			}
		fi
	fi
	freq=("$profilepath")
	ckreq || return $?

	act "launching    : ${browser}.${profile}"
	func "temporary ini: ${vendordir}/profiles.ini"
	mkdir -p    "$vendordir"
	cat <<EOF > "$vendordir"/profiles.ini
[General]
StartWithLastProfile=0
[Profile0]
Name=${browser}
IsRelative=0
Path=${profilepath}
EOF

	# Inject preferences. We are lucky in browsers of the mozilla
	# family the appended settings override preceeding ones and the
	# unknown ones are ignored
	rm -f "$profilepath"/user.js
	for i in ${prefs}; do
		[[ "$i" = "" ]] || {
			act "preference: $i"
			cat "$i" >> "$profilepath"/user.js
		}
	done
	# TODO: interesting to add preference locking functionality
    # see: http://kb.mozillazine.org/Locking_preferences

	### TODO: EXTENSION INJECTION IS NOT YET WELL IMPLEMENTED
	# make sure all extensions are equipped by the profile
	# mkdir -p "$profilepath"/extensions
	# cp $basedir/titlebar/titlebar-v1@dyne.org.xpi \
	#    "$profilepath"/extensions/titlebar-v1@dyne.org.xpi
	# cp $basedir/passff/bin/passff.xpi "$2"/extensions/passff-v1@dyne.org.xpi

	# [[ -r "$templatedir/extensions" ]] && {
	# 	for x in ${(f)"$(find $templatedir/extensions -name '*.xpi')"}; do
	# 		n=`basename $x`
	# 		[[ -r "$templatedir"/extensions/"$n" ]] || {
	# 			act "$n: equipping missing extension"
	# 			mkdir -p "$profilepath"/extensions/
	# 			cp "$x"  "$profilepath"/extensions/
	# 		}
	# 	done
	# }

    (sleep 5; rm "$vendordir"/profiles.ini) &

	option.is_set -e && {
		cmd=$(option.value -e)
		act "executable: $cmd"
		$cmd
		return $?
	}

	$browser
	return $?

}

# }}}

# {{{ Misc functions

function help_usage() {
	fn help_usage
	act "Usage: tinfoil browser profile_name"
}


## TODO: fix this using pidof and locking inside dirs
function browser_is_running() {
	fn browser_is_running
	req=(browser)
	ckreq || return $?

	local brgrep="[${browser[1]}]$(print $browser | cut -c2-)"
	func "checking ps ax for '$brgrep'"

	pgrep $browser
	[[ $? = 0 ]] && {
		act "$browser found already running, using -no-remote"
		browser_opts+=(-no-remote)		
	}
}

# }}}

# {{{ Pathfinders

# a function that recursively searches through symlinks and scripts to
# find the ultimate ELF binary executable they point to. Assumes that
# a shell script contains the binary to call as first argument to the
# first call to ^exec
function executable_find() {
	fn executable_find $*
	local exe="$1"
	req=(exe)
	ckreq || return $?

	local step="$exe"
	local abs=0
	local found=0
	local exepath
	local exetype
	while [[ $found = 0 ]]; do
		func "$step"
		# find full path to current
		[[ "$step[1]" = "/" ]] && abs=1
		[[ "$step[1]" = "." ]] && abs=1
		if [[ $abs = 0 ]]; then
			exepath=$(command -v $step)
			[[ "$exepath" = "" ]] && {
				error "no executable found in path: $step"
				return 1
			}
			func "abs: $exepath"
			abs=1
		else
			exepath=$step
		fi

		exetype="$(file $exepath)"

		# check if a symlink
		[[ $exetype =~ symbolic ]] && {
			step="$(readlink -f $exepath)"
			func "$exepath -> $step"
			continue
		}

		# check if a script, if yes take first exec
		[[ $exetype =~ shell ]] && {
			func "shell script detected"
			for i in ${(f)"$(cat $exepath)"}; do
				func "$i"
				# bail out if nothing found in script
				found=-1
				[[ $i =~ ^exec ]] && {
					step="${i[(w)2]}"
					func "exec: $step"
					found=0
					abs=0
					break
				}
			done
		}

		[[ $exetype =~ ELF ]] && {
			func "binary found: $exepath ($exetype)"
			print $exepath
			return 0
		}
	done
	return $found
}

## looks for a file in all tinfoil directories giving precedence to
## user customisations in $homedir
function cascade_find() {
	fn cascade_find $*
	local file="$1"
	req=(file)
	ckreq || return $?
	found=""
	[[ -r "${here}/${file}" ]] && {
		found="${here}/${file}"
		return 0
	}
	[[ -r "${homedir}/${file}" ]] && {
		found="${homedir}/${file}"
		return 0
	}
	[[ -r "${confdir}/${file}" ]] && {
		found="${confdir}/${file}"
		return 0
	}
	[[ -r "${basedir}/${file}" ]] && {
		found="${basedir}/${file}"
		return 0
	}
}

function template_find() {
	fn template_find
	req=(browser profile)
	ckreq || return $?

	cascade_find "templates/${browser}.${profile}" && {
	   templatedir="$found"
	   return 0
	}

	cascade_find "templates/${browser}" && {
		templatedir="$found"
		return 0
	}


	cascade_find "templates/${browsertype}" && {
		templatedir="$found"
		return 0
	}

	return 1
}

function prefs_find() {
	fn prefs_find
	req=(browsertype)
	ckreq || return $?

	prefs=()
	case $browsertype in
		mozilla)
			cascade_find "templates/${browsertype}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${browser}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${profile}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${browsertype}.${profile}-prefs.js" && {
				prefs+="$found"
			}

			cascade_find "templates/${browser}.${profile}-prefs.js" && {
				prefs+="$found"
			}

			;;
		chrome)
			# TODO: chromium default preferences
			;;
	esac

	return 0
}

function firejail_find() {
	fn firejail_find
	req=(browser browsertype)
	ckreq || return $?

	firejail_profiles=""

	cascade_find "templates/${browser}.${profile}.firejail" && {
		firejail_profiles+="
include $found"
	}
	cascade_find "templates/${browser}.firejail" && {
		firejail_profiles+="
include $found"
	}
	cascade_find "templates/${browsertype}.firejail" && {
		firejail_profiles+="
include $found"
	}
	return 1
}

# }}}

notice "Tinfoil v0.3"

# {{{ Commands parsed
option_main=(h -help=h v -version=v -tmp: t: -type=t e: -exec=e)
option_subcommands[conf]=""
option.parse $* || return 1
func "subcommand: $subcommand"
option.is_set '-h' && help_usage && return 0

# }}}

# {{{ Main()


# create a new profile
case $subcommand in
	__empty)
		help_usage
		return 0
		;;

	conf)
		# print out the configuration for other wrappers
		browser="${option_params[1]}"
		profile="${option_params[2]}"
		[[ "$profile" = "" ]] && {
			error "usage: $0 conf browser profile"
			return 1
		}
		get_browsertype $browser
		cat <<EOF
browser="$browser"
profile="$profile"
browsertype="$browsertype"
profilepath="~/.tinfoil/profiles/$browser.$profile"
vendorpath="~/.${vendor[$browser]}"
cachepath="~/.cache/${vendor[$browser]}"
EOF
		cmd=`executable_find $browser`
		if [[ "$cmd" = "" ]]; then
			warning "executable not found for: $browser"
		else
			cat <<EOF
browser_executable="$cmd"
EOF
		fi
		firejail_find
		[[ "$firejail_profiles" = "" ]] || {
			# list the loaded profiles
			for i in ${(f)firejail_profiles}; do
				[[ $i =~ ^include ]] &&
cat <<EOF
firejail_profiles+=(${i[(w)2]})
EOF
			done
		}

		return 0
		;;

	# default command start with: tinfoil [browser] [profile]
	__unknown:*)
		browser="${subcommand[(ws@:@)2]}"
		profile="${option_params[1]}"

		act "launching browser $browser with profile $profile"
		if option.is_set -t; then
			browsertype=`option.value -t`
			act "browser type manually selected: $browsertype"
		else
			get_browsertype $browser
		fi

		prefs_find || warning "no preferences found"
		

		if template_find; then
			act "$templatedir"
		else
			warning "no template found in $basedir $homedir $confdir"
		fi

		launch-$browsertype
		return $?

		;;

esac



# # support symlinks to script with tinfoil-profilename
# if [[ $0 =~ tinfoil- ]]; then
# 	profile=$(basename $0)
# 	profile=${profile[(ws:-:)2]}
# fi

# browser_opts=($*)



# browser_is_running $browser


## TODO: tor profile to detect tor on local or remote


# }}}
